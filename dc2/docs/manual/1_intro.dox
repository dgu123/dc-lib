/**
\page intro Introduction

Dataflow languages provide natural support for specifying constraints between objects in dynamic applications, where programs need to react efficiently to changes of their environment. Researchers have long investigated how to take advantage of dataflow constraints by embedding them into mainstream procedural languages. Previous mixed imperative/dataflow systems, however, require syntactic extensions or libraries of ad-hoc data types for binding the imperative program to the dataflow solver.

In this paper, we propose a novel approach that smoothly combines the two paradigms without placing undue burden on the programmer. In our framework, programmers can define ordinary commands of the host imperative language that enforce constraints between objects stored in special memory locations designated as ``reactive''. Differently from previous approaches, reactive objects can be of any legal type in the host language, including primitive data types, pointers, arrays, and structures. Commands defining constraints are automatically re-executed every time their input memory locations change, letting a program behave like a spreadsheet where the values of some variables depend upon the values of other variables. The constraint solving mechanism is handled transparently at the language level by altering the semantics of elementary operations of the host language for reading and modifying objects. We provide a formal semantics and describe a concrete embodiment of our technique into C/C++, showing how to implement it efficiently in conventional platforms using off-the-shelf compilers. We discuss common coding idioms and relevant applications to reactive scenarios, including observer pattern, data structure repair, and incremental computation. The performance of our implementation is compared to state-of-the-art self-adjusting computation frameworks, showing that our approach can be very effective in practice.

*/
